回溯的基本思想：
>核心： 画图， 画出每个一支路，然后看哪里需要剪枝，考虑剪枝的条件。
>
>迭代终止条件： 可能是深度(depth)， 可能是数组的长度(nums.length)，可能是一个目标数(target).

剪枝的基本思想：
>核心是画图看哪里需要剪枝，找到共同的规律。
>
>如果是不能使用重复的元素， 使用布尔类型的used数组进行剪枝。
>
>如果是前面的结果集会对后面的结果集造成重复， 使用开始指针 start来确定每次遍历的起始点。———— 一直向后， 就取不到前面的元素。
有时候这两个会混合使用

add path的时机:
>根据支路完结的条件进行判断， 比如depth达到， length达到， target达到等。
>
>对于子集这类题直接添加即可。
add时候一定要add(new ArrayList<>(path)), 直接add(path) 得到的结果都是[][][][].
 
注意：用于计数和输出结果的static不要放在回溯的参数

回溯的模板
```python
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```